{
  "version": 3,
  "sources": ["../src/utils.js", "../src/utils.js", "../src/proxy-trap.js", "../src/patch.js", "../src/inject.js", "../src/parsers/ejs.js", "../src/store.js", "../src/index.js"],
  "sourcesContent": ["\nconst ATTR = 'hp-live'\nconst ID_PREFIX = 'hp-'\nconst DILEM = '|'\nconst FN = 'fn'\n\nexport default {\n\n  debounce (callback, wait = 0) {\n    let timeout = null\n\n    return function () {\n      const next = () => callback.apply(this, arguments)\n      if (timeout) clearTimeout(timeout)\n      timeout = setTimeout(next, wait)\n    }\n  },\n\n  getShadow (html) {\n    const $tmp = document.createElement('div')\n    $tmp.innerHTML = html\n    return $tmp\n  },\n\n  addId ($el) {\n    const existing = [...$el.attributes].find((attr) => attr.name.startsWith(ID_PREFIX))\n    if (existing) return existing.name.replace(ID_PREFIX, '')\n\n    const min = Date.now()\n    const uniq = Math.round(Math.random() * (9999999999999 - min) + min).toString(36)\n    $el.setAttribute(`${ID_PREFIX}${uniq}`, '')\n    return uniq\n  },\n\n  wrap ($el) {\n    const $wrapper = document.createElement('span')\n    const id = this.addId($wrapper)\n    $el.parentNode.insertBefore($wrapper, $el)\n    $wrapper.append($el)\n    return id\n  },\n\n  findId ($tree, id, single = true) {\n    const search = `[${ID_PREFIX}${id}]`\n    return single ? $tree.querySelector(search) : $tree.querySelectorAll(search)\n  }\n\n  // getMatch: ($el) => document.querySelector(`[${ID}=\"${$el.getAttribute(ID)}\"]`)\n\n}\n", "\nconst ATTR = 'hp-live'\nconst ID_PREFIX = 'hp-'\nconst DILEM = '|'\nconst FN = 'fn'\n\nexport default {\n\n  debounce (callback, wait = 0) {\n    let timeout = null\n\n    return function () {\n      const next = () => callback.apply(this, arguments)\n      if (timeout) clearTimeout(timeout)\n      timeout = setTimeout(next, wait)\n    }\n  },\n\n  getShadow (html) {\n    const $tmp = document.createElement('div')\n    $tmp.innerHTML = html\n    return $tmp\n  },\n\n  addId ($el) {\n    const existing = [...$el.attributes].find((attr) => attr.name.startsWith(ID_PREFIX))\n    if (existing) return existing.name.replace(ID_PREFIX, '')\n\n    const min = Date.now()\n    const uniq = Math.round(Math.random() * (9999999999999 - min) + min).toString(36)\n    $el.setAttribute(`${ID_PREFIX}${uniq}`, '')\n    return uniq\n  },\n\n  wrap ($el) {\n    const $wrapper = document.createElement('span')\n    const id = this.addId($wrapper)\n    $el.parentNode.insertBefore($wrapper, $el)\n    $wrapper.append($el)\n    return id\n  },\n\n  findId ($tree, id, single = true) {\n    const search = `[${ID_PREFIX}${id}]`\n    return single ? $tree.querySelector(search) : $tree.querySelectorAll(search)\n  }\n\n  // getMatch: ($el) => document.querySelector(`[${ID}=\"${$el.getAttribute(ID)}\"]`)\n\n}\n", "\nimport Utils from './utils.js'\n\nexport default {\n  create (data, callback) {\n    let que = []\n\n    const _debounced = Utils.debounce(() => {\n      callback(que)\n      que = []\n    }, 10)\n\n    const _addToQue = path => {\n      if (!que.includes(path)) que.push(path)\n      _debounced(que)\n    }\n\n    function _buildProxy (raw, tree = []) {\n      return new Proxy(raw, {\n        get: function (target, prop) {\n          const value = Reflect.get(...arguments)\n\n          if (value && typeof value === 'object' && ['Array', 'Object'].includes(value.constructor.name)) {\n            return _buildProxy(value, tree.concat(prop))\n          }\n\n          return value\n        },\n\n        set: function (target, prop, value) {\n          const ret = Reflect.set(...arguments)\n          const path = tree.concat(prop).join('.')\n          _addToQue(path)\n          return ret\n        },\n\n        deleteProperty: function (target, prop) {\n          const ret = Reflect.deleteProperty(...arguments)\n          const path = tree.concat(prop).join('.')\n          _addToQue(path)\n          return ret\n        }\n      })\n    }\n\n    return _buildProxy(data)\n  }\n}\n", "\nimport Utils from './utils.js'\n\nconst SPECIAL = {\n  text ($r, $v) {\n    $r.innerText = $v.innerText\n  },\n  value ($r, $v) {\n    if ($v.value) $r.value = $v.value\n    else $r.value = ''\n  }\n}\n\nexport default function ($vTree, needsPatched, trace) {\n  console.groupCollapsed('updates')\n\n  Object.entries(needsPatched).forEach(([id, props]) => {\n    // console.log(id, props)\n    const $v = Utils.findId($vTree, id, true)\n    const $r = Utils.findId(document, id, true)\n\n    if ($r && $v) {\n      props.forEach(prop => {\n        if (trace) console.log('setting', prop, $r)\n        if (prop in SPECIAL) SPECIAL[prop]($r, $v)\n        else $r.setAttribute(prop, $v.getAttribute(prop))\n      })\n    }\n  })\n\n  console.groupEnd()\n}\n", "\nimport Utils from './utils.js'\nconst TXT_VALUE = ['TEXTAREA']\n\nexport default function (tpl, parser, store) {\n  function _getKeys (outlets) {\n    outlets = outlets || []\n    return outlets.map(match => match.replace(parser.outlet, (match, path) => path))\n  }\n\n  function _handleProps ($el) {\n    const id = Utils.addId($el)\n\n    const dynamic = Array.from($el.attributes).reduce((acc, att) => {\n      const {name, value} = att\n      const keys = _getKeys(att.value.match(parser.outlet))\n      if (keys.length) acc[name] = keys\n      return acc\n    }, {})\n\n    if (Object.keys(dynamic).length) {\n      Object.entries(dynamic).forEach(([key, triggers]) => store.addProp(id, key, triggers))\n    }\n  }\n\n  function _textNode ($el) {\n    const $parent = $el.parentElement\n    const matches = $el.textContent.match(parser.outlet)\n\n    if (matches && matches.length) {\n      const triggers = _getKeys(matches)\n\n      if ($parent && TXT_VALUE.includes($parent.tagName)) {\n        const id = Utils.addId($parent)\n        store.addProp(id, 'value', triggers)\n      } else {\n        const id = Utils.wrap($el)\n        store.addProp(id, 'text', triggers)\n      }\n    } else {\n      const iterations = $el.textContent.match(parser.iterate)\n      if (iterations && iterations.length) {\n        const $parent = $el.parentNode\n\n        iterations.forEach(match => {\n          $el.parentNode.setAttribute('hp-iterate', Array.from(iterations).map(match => {\n            return match.replace(parser.iterate, (match, key) => key)\n          }).join(','))\n        })\n      }\n    }\n  }\n\n  function _injectNode ($el) {\n    if ($el.nodeType === Node.TEXT_NODE) _textNode($el)\n    else _handleProps($el)\n\n    Array.from($el.childNodes).forEach(_injectNode)\n  }\n\n  const $shadow = Utils.getShadow(tpl)\n  const cleanup = parser.cleanup || []\n\n  Array.from($shadow.childNodes).forEach(_injectNode)\n  let injected = $shadow.innerHTML\n\n  cleanup.forEach(({search, replace}) => {\n    injected = injected.replace(search, replace)\n  })\n  return injected\n}\n", "\nexport default {\n  outlet: /<%=\\s*([^<% ]+)\\s*%>/gm,\n  iterate: /<%\\s*(.*).forEach\\s*\\(/gm,\n\n  cleanup: [\n    {search: /%&gt;/g, replace: '%>'},\n    {search: /&lt;%/g, replace: '<%'},\n    {search: /=&gt;/g, replace: '=>'}\n  ]\n}\n", "export default {\n\n  create () {\n    const stash = {}\n\n    return {\n      stash,\n      addProp (id, prop, triggers) {\n        const existing = stash[id]\n\n        if (existing) {\n          existing[prop] = triggers\n        } else {\n          stash[id] = { [prop]: triggers}\n        }\n      },\n\n      find (changed) {\n        return Object.entries(stash).reduce((ret, [id, item]) => {\n          const props = Object.keys(item).filter(key => {\n            return changed.some(change => item[key].includes(change))\n          })\n          if (props.length) ret[id] = props\n          return ret\n        }, {})\n      }\n    }\n  }\n\n}\n", "\nimport Utils from './utils.js'\nimport ProxyTrap from './proxy-trap.js'\nimport Patch from './patch.js'\nimport Inject from './inject.js'\nimport ejs from './parsers/ejs.js'\nimport Store from './store.js'\n\nexport default {\n  parsers: {\n    ejs\n  },\n\n  app ({template, data, parser, render, trace}) {\n    const store = Store.create()\n    const injected = Inject(template, parser, store)\n\n    const trap = ProxyTrap.create(data, function (changed) {\n      const $v = Utils.getShadow(render(injected, trap))\n      const toPatch = store.find(changed)\n      const startTime = new Date().getTime()\n\n      if (trace) {\n        console.group('changed:', changed)\n        console.log('needs patched:', toPatch)\n        console.log('vDom:', $v)\n      }\n\n      Patch($v, toPatch, trace)\n\n      if (trace) {\n        const endTime = new Date().getTime()\n        console.log('re-render took:', (endTime - startTime), 'ms')\n        console.groupEnd()\n      }\n    })\n\n    if (trace) {\n      console.log(store.stash)\n    }\n\n    return {data: trap, template: injected, store}\n  }\n\n}\n"],
  "mappings": "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",
  "names": []
}
